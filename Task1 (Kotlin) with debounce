import kotlinx.coroutines.*
import kotlin.system.measureTimeMillis

// callback based async counterpart
suspend fun <T, R> asyncMap(list: List<T>, callback: suspend (T) -> R): List<R> {
    val results = mutableListOf<R>()
    for (item in list) {
        results.add(callback(item))
    }
    return results
}

// demo case for the usage
fun main() = runBlocking {
    val numbers = listOf(1, 2, 3, 4, 5)

    val asyncDouble: suspend (Int) -> Int = { num ->
        delay(1000)
        num * 3
    }

    val startTime = System.currentTimeMillis()

    val results = asyncMap(numbers, asyncDouble)
    println(results)

    val endTime = System.currentTimeMillis()
    println("Program execution time: ${endTime - startTime} ms")
}
